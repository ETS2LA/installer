# ORIGINAL COMMIT: https://github.com/ETS2LA/installer/commit/d6088b23bc237ae515babca4011dc7e6634db334
# Edited by Tumppi066 to add a language dialog!

import re
# output to languages.nsh
# first, list languages/
from dataclasses import dataclass
from pathlib import Path

ALL_LOCALES = [
    "Serbian", "Vietnamese", "Asturian", "Greek", "Turkish", "Georgian",
    "Norwegian", "Macedonian", "Hebrew", "Belarusian", "PortugueseBR", "Welsh",
    "Korean", "Japanese", "Estonian", "Afrikaans", "ScotsGaelic", "Czech",
    "Esperanto", "Kurdish", "Lithuanian", "Latvian", "Pashto", "Bosnian",
    "Croatian", "French", "Farsi", "Hindi", "Hungarian", "SerbianLatin",
    "Bulgarian", "SimpChinese", "Indonesian", "Slovenian", "Albanian",
    "Arabic", "Armenian", "Ukrainian", "German", "Catalan", "Malay", "Swedish",
    "Thai", "Portuguese", "Icelandic", "Luxembourgish", "Irish", "TradChinese",
    "Uzbek", "SpanishInternational", "Basque", "Polish", "NorwegianNynorsk",
    "Tatar", "Russian", "Finnish", "Breton", "Galician", "Mongolian", "Dutch",
    "Spanish", "Romanian", "English", "Italian", "Danish", "Slovak", "Corsican"
]


def auto_match_locale(name: str) -> str:
    if name.startswith("LANG_"):
        name = name[5:]

    for locale in ALL_LOCALES:
        if locale.lower() == name.lower():
            return locale

    raise ValueError(f"Could not match locale {name}")


def find_locale_identifier(path: Path) -> str:
    # iterate lines, find \${.+}
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            match = re.search(r"\${(.+?)}", line)
            if match:
                return match.group(1)
    raise ValueError(f"Could not find locale identifier in {path}")


def auto_fix_utf8bom(path: Path):
    # if not bom, add it
    with open(path, "rb") as f:
        if f.read(3) != b'\xef\xbb\xbf':
            with open(path, "r+", encoding="utf-8") as f2:
                content = f2.read()
                f2.seek(0)
                f2.write('\ufeff' + content)
                f2.truncate()


@dataclass
class Locale:
    name: str
    path: Path
    
    def __str__(self):
        return f"Locale(name={self.name}, path={self.path})"


locales: list[Locale] = []
lang_dir = Path("languages")

for file in lang_dir.glob("*.nsh"):
    auto_fix_utf8bom(file)
    locales.append(Locale(file.stem, file))
    
with open("languages.nsh", "w", encoding="utf-8") as f:
    f.write("; DON'T EDIT!\n")
    f.write("; This file is automatically generated by auto_precompile.py\n")
    f.write('!include "MUI2.nsh"\n')
    
    # Load language files
    for locale in locales:
        locale_identifier = find_locale_identifier(locale.path)
        locale_name = auto_match_locale(locale_identifier)

        f.write(
            f'!insertmacro MUI_LANGUAGE "{locale_name}"\n'
        )

    f.write("\n")
    
    # Write include statements
    for locale in locales:
        text = '!include "' + locale.path.as_posix().replace('/', '\\') + '"\n'
        f.write(text)
        
    f.write("\n")
    # Write .onInit with language selection
    f.write('Function .onInit\n   Push ""\n')
    for locale in locales:
        identifier = find_locale_identifier(locale.path)
        f.write("   Push ${" + identifier + "}\n")
    
        name = auto_match_locale(identifier)
        if name == "TradChinese": name = "Traditional Chinese"
        if name == "SimpChinese": name = "Simplified Chinese"
            
        f.write(f'   Push "{name}"\n')
    
    f.write('   Push A\n')
    f.write('   LangDLL::LangDialog $(InstallerLanguage) $(InstallerLanguageText)\n')
    f.write('   Pop $LANGUAGE\n')
    f.write('   StrCmp $LANGUAGE "cancel" 0 +2\n')
    f.write('       Abort\n')
    f.write('FunctionEnd')